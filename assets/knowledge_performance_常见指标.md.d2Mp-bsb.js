import{_ as a,c as i,o as e,U as t}from"./chunks/framework.n5rCxQTk.js";const u=JSON.parse('{"title":"常见的性能指标","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/performance/常见指标.md","filePath":"knowledge/performance/常见指标.md"}'),s={name:"knowledge/performance/常见指标.md"},n=t(`<h1 id="常见的性能指标" tabindex="-1">常见的性能指标 <a class="header-anchor" href="#常见的性能指标" aria-label="Permalink to &quot;常见的性能指标&quot;">​</a></h1><blockquote><p><a href="https://github.com/berwin/Blog/issues/46" target="_blank" rel="noreferrer">Web 性能领域常见的专业术语</a> &gt; <a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics" target="_blank" rel="noreferrer">以用户为中心的性能指标</a></p></blockquote><h2 id="ttfb-全称-time-to-first-byte" tabindex="-1">TTFB（全称“Time to First Byte”） <a class="header-anchor" href="#ttfb-全称-time-to-first-byte" aria-label="Permalink to &quot;TTFB（全称“Time to First Byte”）&quot;">​</a></h2><p>表示浏览器接收第一个字节的时间</p><ul><li><code>performance.getEntriesByType(&#39;navigation&#39;)</code></li><li><code>responseStart - fetchStart</code></li></ul><h2 id="dcl" tabindex="-1">DCL <a class="header-anchor" href="#dcl" aria-label="Permalink to &quot;DCL&quot;">​</a></h2><p>表示 DomContentloaded 事件触发的时间。</p><ul><li><code>performance.getEntriesByType(&#39;navigation&#39;)</code></li><li><code>domContentLoadedEventEnd - fetchStart</code></li></ul><h2 id="l" tabindex="-1">L <a class="header-anchor" href="#l" aria-label="Permalink to &quot;L&quot;">​</a></h2><p>表示 onLoad 事件触发的时间。</p><p>DomContentloaded 事件与 onLoad 事件的区别是，浏览器解析 HTML 这个操作完成后立刻触发 DomContentloaded 事件，而只有页面所有资源都加载完毕后（比如图片，CSS），才会触发 onLoad 事件。</p><p><img src="https://user-images.githubusercontent.com/20217146/83966080-a7d83700-a8ea-11ea-9ac6-c8d39166b454.png" alt="image"></p><ul><li><code>performance.getEntriesByType(&#39;navigation&#39;)</code></li><li><code>loadEventStart - fetchStart</code></li></ul><h2 id="fp-全称-first-paint-翻译为-首次绘制" tabindex="-1">FP（全称“First Paint”，翻译为“首次绘制”） <a class="header-anchor" href="#fp-全称-first-paint-翻译为-首次绘制" aria-label="Permalink to &quot;FP（全称“First Paint”，翻译为“首次绘制”）&quot;">​</a></h2><p>是时间线上的第一个“时间点”，它代表浏览器第一次向屏幕传输<strong>像素</strong>的时间，也就是页面在屏幕上首次发生视觉变化的时间。</p><ul><li><code>performance.getEntriesByName(&#39;first-paint&#39;) </code></li></ul><h2 id="fcp-全称-first-contentful-paint-翻译为-首次内容绘制" tabindex="-1">FCP（全称“First Contentful Paint”，翻译为“首次内容绘制”） <a class="header-anchor" href="#fcp-全称-first-contentful-paint-翻译为-首次内容绘制" aria-label="Permalink to &quot;FCP（全称“First Contentful Paint”，翻译为“首次内容绘制”）&quot;">​</a></h2><p>顾名思义，它代表浏览器第一次向屏幕绘制 “<strong>内容</strong>”(文本，图片，SVG，canvas 元素等)</p><ul><li><code>performance.getEntriesByName(&#39;first-contentful-paint&#39;)</code></li><li><a href="https://web.dev/fcp/#measure-fcp-in-javascript" target="_blank" rel="noreferrer">https://web.dev/fcp/#measure-fcp-in-javascript</a></li></ul><h2 id="fmp-全称-first-meaningful-paint-翻译为-首次有效绘制" tabindex="-1">FMP（全称“First Meaningful Paint”，翻译为“首次有效绘制”） <a class="header-anchor" href="#fmp-全称-first-meaningful-paint-翻译为-首次有效绘制" aria-label="Permalink to &quot;FMP（全称“First Meaningful Paint”，翻译为“首次有效绘制”）&quot;">​</a></h2><p>表示页面的“<strong>主要内容</strong>”开始出现在屏幕上的时间点。它是我们测量用户加载体验的主要指标。</p><ul><li>FMP 是一个十分主观的指标，需要开发者自己去测量。像文章一开始说的那样，我们可以在业务逻辑中判断页面加载、渲染完成时记录一个时间戳，然后和 window.performance.timing.fetchStart 相减，来得到 FMP。</li><li><a href="https://github.com/berwin/Blog/issues/42" target="_blank" rel="noreferrer">https://github.com/berwin/Blog/issues/42</a></li></ul><h2 id="lcp-全称-largest-contentful-paint" tabindex="-1">LCP（全称“Largest Contentful Paint”） <a class="header-anchor" href="#lcp-全称-largest-contentful-paint" aria-label="Permalink to &quot;LCP（全称“Largest Contentful Paint”）&quot;">​</a></h2><p>表示可视区“内容”最大的可见元素开始出现在屏幕上的时间点。 <img src="https://user-images.githubusercontent.com/20217146/83966295-f63a0580-a8eb-11ea-80bd-11f4529da1b9.png" alt="image"></p><ul><li><a href="https://web.dev/lcp/#measure-lcp-in-javascript" target="_blank" rel="noreferrer">https://web.dev/lcp/#measure-lcp-in-javascript</a></li></ul><p>了解和测量网站真实的性能其实非常困难，像 load 和 DOMContentLoaded 不会告诉我们用户什么时候可以在屏幕上看到内容。而 FP 和 FCP 又只能捕获整个渲染过程的最开始，FMP 更好一点，但是它的算法比较复杂，而且有时候不准。FP 与 FCP 可以让我们知道，我们的产品何时开始渲染；而 FMP 与 LCP 可以让我们了解我们的产品何时“有用”，站在用户的角度，FMP 与 LCP 可以表示我们的产品需要多久才能体现出价值。</p><p>注意，这里说的是“有用”，而不是“能用”；那我们如何才能知道我们的产品什么时候“能用”呢？这就需要另一个性能指标“TTI”了。</p><h2 id="tti-全称-time-to-interactive-翻译为-可交互时间" tabindex="-1">TTI（全称“Time to Interactive”，翻译为“可交互时间”） <a class="header-anchor" href="#tti-全称-time-to-interactive-翻译为-可交互时间" aria-label="Permalink to &quot;TTI（全称“Time to Interactive”，翻译为“可交互时间”）&quot;">​</a></h2><p>表示网页第一次 完全达到可交互状态 的时间点。可交互状态指的是页面上的 UI 组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过 50 毫秒。TTI 很重要，因为 TTI 可以让我们了解我们的产品需要多久可以真正达到“可用”的状态。DCL 之后理论上可交互了，但如果此时又执行了 LongTask，页面又卡死了，所以 DCL 并不能代表真实的“可用”状态。 <img src="https://web-dev.imgix.net/image/admin/krOoeuQ4TWCbt9t6v5Wf.svg" alt="FCP、TTI、FID"></p><ul><li>使用 <a href="https://github.com/GoogleChromeLabs/tti-polyfill" target="_blank" rel="noreferrer">tti-polyfill</a></li></ul><h2 id="fci-first-cpu-idle" tabindex="-1">FCI（First CPU Idle） <a class="header-anchor" href="#fci-first-cpu-idle" aria-label="Permalink to &quot;FCI（First CPU Idle）&quot;">​</a></h2><p>是对 TTI 的一种补充，TTI 可以告诉我们页面什么时候完全达到可用，但是我们不知道浏览器第一次可以响应用户输入是什么时候。我们不知道网页的“最小可交互时间”是多少，最小可交互时间是说网页的首屏已经达到了可交互的状态了，但整个页面可能还没达到。从名字也可以看出这个指标的意思，第一次 CPU 空闲，主线程空闲就代表可以接收用户的响应了。</p><h2 id="fid-first-input-delay" tabindex="-1">FID（First Input Delay） <a class="header-anchor" href="#fid-first-input-delay" aria-label="Permalink to &quot;FID（First Input Delay）&quot;">​</a></h2><p>第一输入延迟。衡量交互性，小于 100ms 为佳。</p><ul><li>将事件时间戳与当前时间作比较 <code>performance.now() - event.timeStamp;</code></li><li><a href="https://web.dev/fid/#measure-fid-in-javascript" target="_blank" rel="noreferrer">https://web.dev/fid/#measure-fid-in-javascript</a></li></ul><h2 id="tbt-total-blocking-time" tabindex="-1">TBT (Total Blocking Time) <a class="header-anchor" href="#tbt-total-blocking-time" aria-label="Permalink to &quot;TBT (Total Blocking Time)&quot;">​</a></h2><p>总阻塞时间(TBT)指标衡量了从第一次有内容的绘画(FCP)到交互时间(TTI)之间的，主线程被阻塞到足以阻止输入响应性的总阻塞时间。 <img src="https://user-images.githubusercontent.com/20217146/155867351-5a1f2823-aef9-4cc3-814b-02f39d2990c2.png" alt="image"></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;longtask&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  entries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // get long task time in fcp -&gt; tti</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (entry.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;self&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry.startTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fcp) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // long tasks mean time over 50ms</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> blockingTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry.duration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (blockingTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) tbt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> blockingTime;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="cls-cumulative-layout-shift" tabindex="-1">CLS (Cumulative Layout Shift) <a class="header-anchor" href="#cls-cumulative-layout-shift" aria-label="Permalink to &quot;CLS (Cumulative Layout Shift)&quot;">​</a></h2><p>累计布局偏移（CLS）是一个重要的、以用户为中心的衡量视觉稳定性的指标，因为它有助于量化用户经历意外布局偏移的频率 --较低的 CLS 有助于确保页面令人愉悦。</p><p><img src="https://user-images.githubusercontent.com/20217146/155867389-2a091beb-4f8d-422a-98f6-5822c5951382.png" alt="image"> CLS=影响分数 ✕ 距离分数 75%✕25%=0.1875</p><ul><li><a href="https://web.dev/cls/#measure-cls-in-javascript" target="_blank" rel="noreferrer">https://web.dev/cls/#measure-cls-in-javascript</a></li></ul><h2 id="si-speed-index" tabindex="-1">SI (<a href="https://web.dev/speed-index/" target="_blank" rel="noreferrer">Speed Index</a>) <a class="header-anchor" href="#si-speed-index" aria-label="Permalink to &quot;SI ([Speed Index](https://web.dev/speed-index/))&quot;">​</a></h2><p>衡量的是页面加载过程中内容在视觉上的显示速度。Lighthouse 首先在浏览器中抓取页面加载的视频，并计算出各帧之间的视觉进度。</p><h1 id="lighthouse-性能评分体系" tabindex="-1"><a href="https://web.dev/performance-scoring/" target="_blank" rel="noreferrer">lighthouse 性能评分体系</a> <a class="header-anchor" href="#lighthouse-性能评分体系" aria-label="Permalink to &quot;[lighthouse 性能评分体系](https://web.dev/performance-scoring/)&quot;">​</a></h1>`,45),l=[n];function r(h,p,o,d,c,k){return e(),i("div",null,l)}const f=a(s,[["render",r]]);export{u as __pageData,f as default};
