import{_ as o,c as s,o as t,U as n}from"./chunks/framework.n5rCxQTk.js";const h=JSON.parse('{"title":"Vue2 Diff 算法","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/Diff算法/vue2.md","filePath":"knowledge/framework/Diff算法/vue2.md"}'),r={name:"knowledge/framework/Diff算法/vue2.md"},e=n('<h1 id="vue2-diff-算法" tabindex="-1">Vue2 Diff 算法 <a class="header-anchor" href="#vue2-diff-算法" aria-label="Permalink to &quot;Vue2 Diff 算法&quot;">​</a></h1><h2 id="_1-特点" tabindex="-1">1. 特点 <a class="header-anchor" href="#_1-特点" aria-label="Permalink to &quot;1. 特点&quot;">​</a></h2><ol><li><p><strong>双端比较</strong>：双端比较就是新列表和旧列表两个列表的头与尾互相对比，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的节点全部遍历过，对比停止</p></li><li><p><strong>同层级比较</strong>：Vue 的 Diff 算法只比较同一层级的节点，不进行跨层级的比较。</p></li><li><p><strong>节点重用</strong>：当节点具有相同的标签和 key 时，Vue 会尝试重用这些节点，减少了不必要的 DOM 操作。</p></li></ol><h3 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><ol><li><p><strong>最坏情况</strong>：在最坏的情况下，算法可能需要访问树中的每个节点。因此，最坏情况的时间复杂度是 O(n)，其中 <code>n</code> 是虚拟 <code>DOM</code> 树中节点的总数。</p></li><li><p><strong>平均情况</strong>：Vue 的 Diff 算法采用了一些优化策略（如双端比较和同层级节点的比较），这可以在许多常见场景中减少所需的比较次数。这些优化意味着平均情况下的时间复杂度通常低于 O(n)。</p></li></ol><h3 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h3><ol><li><p><strong>虚拟<code>DOM</code>存储</strong>：由于需要存储整个虚拟 DOM 树的结构，所以空间复杂度至少是 O(n)，n 是树中节点的数量。</p></li><li><p><strong>额外空间</strong>：在 Diff 过程中，Vue 需要额外的空间来存储节点间的映射关系和其他辅助信息，通常也不会超过 O(n)。</p></li></ol><h2 id="_2-双端比较" tabindex="-1">2. 双端比较 <a class="header-anchor" href="#_2-双端比较" aria-label="Permalink to &quot;2. 双端比较&quot;">​</a></h2><p>定义比较节点：</p><ul><li><strong>旧列表</strong>的<strong>第一个节点</strong><code>oldStartNode</code></li><li><strong>新列表</strong>的<strong>第一个节点</strong><code>newStartNode</code></li><li><strong>旧列表</strong>的<strong>最后一个节点</strong><code>oldEndNode</code></li><li><strong>新列表</strong>的<strong>最后一个节点</strong><code>newEndNode</code></li></ul><p>定义指针：</p><ul><li><strong>旧列表</strong>的<strong>头指针</strong><code>oldStartIndex</code></li><li><strong>新列表</strong>的<strong>尾指针</strong><code>newEndIndex</code></li><li><strong>旧列表</strong>的<strong>尾指针</strong><code>oldEndIndex</code></li><li><strong>新列表</strong>的<strong>尾指针</strong><code>newEndIndex</code></li></ul><h3 id="_1-循环比较" tabindex="-1">1. 循环比较 <a class="header-anchor" href="#_1-循环比较" aria-label="Permalink to &quot;1. 循环比较&quot;">​</a></h3><p>我们按照以下几个步骤进行对比、移位和更新 dom 操作：</p><ol><li><p>如果<strong>旧列表</strong>的<strong>第一个节点</strong><code>oldStartNode</code>与<strong>新列表</strong>的<strong>第一个节点</strong><code>newStartNode</code>对比时 key 相同。<br> 那么:</p><ul><li><p>在<strong>旧列表</strong>中就是<strong>第一个节点</strong>，在<strong>新列表</strong>中也是<strong>第一个节点</strong>，所以<code>dom</code>位置不变</p></li><li><p><strong>旧列表</strong>的<strong>头指针</strong><code>oldStartIndex</code>与<strong>新列表</strong>的<strong>头指针</strong><code>newStartIndex</code>同时向后移动一位。</p></li></ul></li><li><p>如果<strong>旧列表</strong>的<strong>最后一个节点</strong><code>oldEndNode</code>与<strong>新列表</strong>的<strong>最后一个节点</strong><code>newEndNode</code>对比时 key 相同。<br> 那么:</p><ul><li>在<strong>旧列表</strong>中就是<strong>最后一个节点</strong>，在<strong>新列表</strong>中也是<strong>最后一个节点</strong>，所以<code>dom</code>位置不变</li><li><strong>旧列表</strong>的<strong>尾指针</strong><code>oldEndIndex</code>与<strong>新列表</strong>的<strong>尾指针</strong><code>newEndIndex</code>同时向前移动一位。</li></ul></li><li><p>如果<strong>旧列表</strong>的<strong>第一个节点</strong><code>oldStartNode</code>与<strong>新列表</strong>的<strong>最后一个节点</strong><code>newEndNode</code>对比时 key 相同。<br> 那么:</p><ul><li>更新前<strong>旧列表</strong>的<strong>第一个节点</strong>，现在是<strong>新列表</strong>中的<strong>最后一个节点</strong>，所以把当前的节点移动到<strong>旧列表</strong>中的<strong>最后一个节点</strong>后面，让它成为新的<strong>最后一个节点</strong></li><li><strong>旧列表</strong>的<strong>头指针</strong><code>oldStartIndex</code>向后移动一位；<strong>新列表</strong>的<strong>尾指针</strong><code>newEndIndex</code>向前移动一位。</li></ul></li><li><p>如果<strong>旧列表</strong>的<strong>最后一个节点</strong><code>oldEndNode</code>与<strong>新列表</strong>的<strong>第一个节点</strong><code>newStartNode</code>对比时 key 相同。<br> 那么:</p><ul><li>更新前是<strong>旧列表</strong>的<strong>最后一个节点</strong>，现在是<strong>新列表</strong>中的<strong>第一个节点</strong>，所以把当前的节点移动到<strong>旧列表</strong>中的<strong>第一个节点</strong>之前，让它成为新的<strong>第一个节点</strong></li><li><strong>旧列表</strong>的<strong>尾指针</strong><code>oldEndIndex</code>向前移动一位；<strong>新列表</strong>的<strong>头指针</strong><code>newStartIndex</code>向后移动一位。</li></ul></li><li><p>如果四次对比都没找到复用节点时，那么拿<strong>新列表</strong>的<strong>第一个节点</strong><code>newStartNode</code>去旧列表中找与其 key 相同的节点:</p><ol><li>如果<strong>旧列表</strong>中找到对应的节点，那么： <ul><li>将<strong>旧列表</strong>节点对应的<code>DOM</code>元素移动到开头</li><li>将<strong>旧列表</strong>中的节点设置为<code>undefined</code>，即移除<strong>旧列表</strong>中的对应节点 <blockquote><p>此处和<strong>步骤 4</strong>中的方式类似，<strong>步骤 4</strong> 将<code>oldEndIndex</code>向前移动一位等同于将<strong>旧列表</strong>中的节点设置为<code>undefined</code>，目的都是移除<strong>旧列表</strong>中的对应节点</p></blockquote></li></ul></li><li>如果<strong>旧列表</strong>中没有找到对应的节点，那么： <ul><li>那么创建一个新的节点放到最前面</li><li><strong>头指针</strong><code>newStartIndex</code>向后移动一位</li></ul></li></ol></li></ol><h3 id="_2-循环比较之后" tabindex="-1">2. 循环比较之后 <a class="header-anchor" href="#_2-循环比较之后" aria-label="Permalink to &quot;2. 循环比较之后&quot;">​</a></h3><ol><li><p>当<code>oldEndIndex</code>小于<code>oldStartIndex</code>，说明<strong>新列表</strong>中还有剩余的节点，说明存在新增节点<br> 此时将剩余的节点依次插入到<code>oldStartIndex</code>对应的<code>DOM</code>之后就可以了</p></li><li><p>反之，当<code>oldEndIndex</code>大于<code>oldStartIndex</code>，说明剩下的节点已经被删除，直接对应的<code>DOM</code>删除即可</p></li></ol><h2 id="举例" tabindex="-1">举例 <a class="header-anchor" href="#举例" aria-label="Permalink to &quot;举例&quot;">​</a></h2><p>列表 <code>a, b, c, d, e</code> 更新为 <code>d, e, f, a, b, c</code> 的情况时</p><h3 id="初始和更新的列表" tabindex="-1">初始和更新的列表 <a class="header-anchor" href="#初始和更新的列表" aria-label="Permalink to &quot;初始和更新的列表&quot;">​</a></h3><ul><li><strong>原始列表</strong>：<code>a, b, c, d, e</code></li><li><strong>更新后的列表</strong>：<code>d, e, f, a, b, c</code></li></ul><ol><li>第一步</li></ol><ul><li><strong>diff</strong>：d, a, b, c, e</li><li><strong>原始列表</strong>：a, b, c, <s>d</s>, e</li><li><strong>更新后的列表</strong>：<s>d</s>, e, f, a, b, c</li></ul><ol start="2"><li>第二步</li></ol><ul><li><strong>diff</strong>：d, e, a, b, c</li><li><strong>原始列表</strong>：a, b, c, <s>d</s>, <s>e</s></li><li><strong>更新后的列表</strong>：<s>d</s>, <s>e</s>, f, a, b, c</li></ul><ol start="3"><li>第三步</li></ol><ul><li><strong>diff</strong>：d, e, a, b, c</li><li><strong>原始列表</strong>：a, b, <s>c</s>, <s>d</s>, <s>e</s></li><li><strong>更新后的列表</strong>：<s>d</s>, <s>e</s>, f, a, b, <s>c</s></li></ul><ol start="4"><li>第四步</li></ol><ul><li><strong>diff</strong>：d, e, a, b, c</li><li><strong>原始列表</strong>：a, <s>b</s>, <s>c</s>, <s>d</s>, <s>e</s></li><li><strong>更新后的列表</strong>：<s>d</s>, <s>e</s>, f, a, <s>b</s>, <s>c</s></li></ul><ol start="5"><li>第五步</li></ol><ul><li><strong>diff</strong>：d, e, a, b, c</li><li><strong>原始列表</strong>：<s>a</s>, <s>b</s>, <s>c</s>, <s>d</s>, <s>e</s></li><li><strong>更新后的列表</strong>：<s>d</s>, <s>e</s>, f, <s>a</s>, <s>b</s>, <s>c</s></li></ul><ol start="6"><li>第六步</li></ol><ul><li><strong>diff</strong>：d, e, f, a, b, c</li><li><strong>原始列表</strong>：<s>a</s>, <s>b</s>, <s>c</s>, <s>d</s>, <s>e</s></li><li><strong>更新后的列表</strong>：<s>d</s>, <s>e</s>, <s>f</s>, <s>a</s>, <s>b</s>, <s>c</s></li></ul>',33),l=[e];function d(g,i,a,c,u,f){return t(),s("div",null,l)}const b=o(r,[["render",d]]);export{h as __pageData,b as default};
