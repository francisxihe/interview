import{_ as o,c as e,o as r,U as a}from"./chunks/framework.n5rCxQTk.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/webpack/loader.md","filePath":"knowledge/framework/webpack/loader.md"}'),l={name:"knowledge/framework/webpack/loader.md"},d=a('<p>我们知道，当用多个 loader 去解析某个类型的文件时，会按照 从右到左，从下到上的顺序执行 loader，那为什么会这样呢？ loader 的两个阶段</p><p>首先，loader 分为两个阶段：</p><p>Pitching 阶段：也就是去执行 loader 身上的 pitch 方法，loader.pitch 可以有返回值，会按照 post(后置)、inline(行内)、noraml(普通)、pre(前置) 的类型顺序调用 loader</p><p>function loader1(content) { return content } //其实就是去执行 loader1 身上的 pitch 方法 loader1.pitch = function() { console.log(&#39; loader1 的 pitching 阶段&#39;) }</p><p>normal 阶段：也就是去执行 loader 本身这个函数，会按照 pre(前置)、noraml(普通)、inline(行内)、noraml(普通)、post(后置) 的类型顺序调用 loader，模块源码的转换发生在这个阶段，也就是上面 return content 的这个地方</p><p>然后，对于同类型的 loader，他们的顺序才会按照从右往左，从下到上的顺序</p><p>注意：在 Loader 的运行过程中，如果发现该 Loader 上有 pitch 属性，会先执行 pitch 阶段，再执行 normal 阶段</p><p>Webpack 设计了四种不同类型的 loader（<code>pre</code>、<code>normal</code>、<code>inline</code>、<code>post</code>）主要是为了提供更灵活和精细的控制方式，确保开发者可以根据需要精确地处理资源文件。每种类型的 loader 都有其特定的用途和优势：</p><ol><li><p><strong>预先执行（<code>pre</code>）的 Loader</strong>:</p><ul><li><strong>用途</strong>：这类 loader 通常用于在正常编译之前执行一些操作。例如，<code>eslint-loader</code> 可以在代码转换之前执行，确保所有代码都遵循特定的编码标准。</li><li><strong>优势</strong>：保证代码在进入主编译流程之前符合某些标准或规则，有助于保持代码质量。</li></ul></li><li><p><strong>普通（<code>normal</code>）的 Loader</strong>:</p><ul><li><strong>用途</strong>：这是最常见的 loader 类型，用于转换模块，如使用 <code>babel-loader</code> 将 ES6 代码转换为兼容旧浏览器的 ES5 代码。</li><li><strong>优势</strong>：作为主要的转换工具，处理大部分文件处理任务。</li></ul></li><li><p><strong>内联（<code>inline</code>）的 Loader</strong>:</p><ul><li><strong>用途</strong>：内联 loader 允许你直接在 require/import 语句中指定 loader。例如，<code>import &#39;style-loader!css-loader!./styles.css&#39;;</code>。</li><li><strong>优势</strong>：提供了对特定模块的即时控制，允许在模块级别覆盖配置文件中的 loader 设置。</li></ul></li><li><p><strong>后置执行（<code>post</code>）的 Loader</strong>:</p><ul><li><strong>用途</strong>：这类 loader 用于在所有常规 loader 处理完毕后再执行。常用于清理、优化任务，比如 <code>PostCSS</code> 插件来自动添加 CSS 前缀。</li><li><strong>优势</strong>：确保在文件最终输出之前，进行必要的优化和调整。</li></ul></li></ol><p>这种设计允许 Webpack 用户非常精确地控制各个 loader 的执行顺序，从而实现复杂和高度自定义的构建过程。这对于大型和复杂的前端项目尤其重要，因为它们通常需要多个转换步骤和细粒度的资源管理。通过正确地组合和配置这些 loader，开发者可以实现高效且可靠的构建流程。</p><h2 id="loader" tabindex="-1">Loader <a class="header-anchor" href="#loader" aria-label="Permalink to &quot;Loader&quot;">​</a></h2><h3 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h3><p>将非 JS 类型文件转换成标准的 JS 代码字符串，因为 webpack 内部默认也只能够处理 JS 模块代码。</p><h3 id="原理-特点" tabindex="-1">原理/特点 <a class="header-anchor" href="#原理-特点" aria-label="Permalink to &quot;原理/特点&quot;">​</a></h3><p>按顺序链式调用每一个 loader，前一个 loader 返回的内容会作为下一个 loader 的入参。</p><h3 id="开发原则" tabindex="-1">开发原则 <a class="header-anchor" href="#开发原则" aria-label="Permalink to &quot;开发原则&quot;">​</a></h3><ul><li>返回值必须是标准的 JS 代码字符串，以保证下一个 loader 能够正常工作</li><li>在开发上需要严格遵循“单一职责”，只关心 loader 的输出以及对应的输出</li></ul>',17),t=[d];function n(i,c,s,p,h,g){return r(),e("div",null,t)}const m=o(l,[["render",n]]);export{_ as __pageData,m as default};
