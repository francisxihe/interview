import{_ as s,c as i,o as a,U as n}from"./chunks/framework.RtLYYSF3.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/programming-paradigm/functional-programming.md","filePath":"knowledge/programming-paradigm/functional-programming.md"}'),t={name:"knowledge/programming-paradigm/functional-programming.md"},l=n(`<h3 id="什么是纯函数" tabindex="-1">什么是纯函数 <a class="header-anchor" href="#什么是纯函数" aria-label="Permalink to &quot;什么是纯函数&quot;">​</a></h3><details class="details custom-block"><summary>题解</summary><p>纯函数（Pure Function）是函数式编程中的一个核心概念，具有以下特点：</p><ol><li><strong>确定性</strong>：</li></ol><p>相同的输入总是得到相同的输出。即，给定相同的参数，纯函数总是返回相同的结果。</p><ol start="2"><li><strong>无副作用</strong>：</li></ol><p>纯函数在执行过程中不会影响或修改任何外部状态（例如全局变量、I/O 设备等）。这意味着它不改变任何外部环境，也不依赖于外部环境的状态。</p><p>这些特性使得纯函数具有几个重要的优点：</p><ol><li><strong>可预测性</strong>：</li></ol><p>由于纯函数对于相同的输入总是产生相同的输出，它们非常可预测。</p><ol start="2"><li><strong>可测试性</strong>：</li></ol><p>纯函数易于测试，因为你只需要考虑其输入和输出。</p><ol start="3"><li><strong>可组合性</strong>：</li></ol><p>纯函数可以安全地组合或链式调用，因为它们之间不会相互干扰。</p><ol start="4"><li><strong>并行处理能力</strong>：</li></ol><p>由于没有副作用，纯函数不需要访问共享的内存或数据，因此它们在并行编程中非常有用。</p><p>举个简单的例子，考虑一个计算两个数之和的函数：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个 <code>add</code> 函数就是一个纯函数，因为它总是对相同的输入返回相同的输出，并且在执行过程中不会产生任何副作用。相比之下，如果一个函数依赖于外部的变量或改变了外部的状态，那么它就不是一个纯函数。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addAndModifyValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改了外部变量 value</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个函数不是纯函数，因为它修改了外部变量 <code>value</code>。</p></details>`,2),p=[l];function e(h,r,k,o,d,g){return a(),i("div",null,p)}const m=s(t,[["render",e]]);export{E as __pageData,m as default};
