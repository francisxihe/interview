import{_ as e,c as a,o as t,U as r}from"./chunks/framework.RtLYYSF3.js";const f=JSON.parse('{"title":"setState 同步异步","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/React.md","filePath":"knowledge/framework/React.md"}'),o={name:"knowledge/framework/React.md"},s=r('<h1 id="setstate-同步异步" tabindex="-1">setState 同步异步 <a class="header-anchor" href="#setstate-同步异步" aria-label="Permalink to &quot;setState 同步异步&quot;">​</a></h1><h1 id="fiber" tabindex="-1"><a href="https://react.iamkasong.com/process/fiber-mental.html#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94" target="_blank" rel="noreferrer">Fiber</a> <a class="header-anchor" href="#fiber" aria-label="Permalink to &quot;[Fiber](https://react.iamkasong.com/process/fiber-mental.html#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94)&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>Fiber 的中文翻译叫纤程，与进程、线程同为程序执行过程，Fiber 就是比线程还要纤细的一个过程。纤程意在对渲染过程实现进行更加精细的控制。</p><p>从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写。</p><p>从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的&quot;虚拟 DOM&quot;。</p><h2 id="架构核心" tabindex="-1">架构核心 <a class="header-anchor" href="#架构核心" aria-label="Permalink to &quot;架构核心&quot;">​</a></h2><p>Fiber 架构可以分为三层：</p><p>Reconciler 协调器 —— 负责找出变化的组件 Renderer 渲染器 —— 负责将变化的组件渲染到页面上 Scheduler 调度器 —— 调度任务的优先级，高优任务优先进入 Reconciler</p><p>Fiber 架构的核心即是&quot;可中断&quot;、&quot;可恢复&quot;、&quot;优先级&quot;</p><h1 id="hooks-原理" tabindex="-1">Hooks 原理 <a class="header-anchor" href="#hooks-原理" aria-label="Permalink to &quot;Hooks 原理&quot;">​</a></h1><h2 id="伪代码" tabindex="-1">伪代码 <a class="header-anchor" href="#伪代码" aria-label="Permalink to &quot;伪代码&quot;">​</a></h2><h2 id="useref、usestate" tabindex="-1">useRef、useState <a class="header-anchor" href="#useref、usestate" aria-label="Permalink to &quot;useRef、useState&quot;">​</a></h2><ul><li>useRef 是保持引用，修改不会引起重新渲染。</li><li>useState 是状态，会引起重新渲染。</li></ul><h2 id="usecallback、usememo" tabindex="-1">useCallback、useMemo <a class="header-anchor" href="#usecallback、usememo" aria-label="Permalink to &quot;useCallback、useMemo&quot;">​</a></h2><ul><li>useMemo 缓存的是第一个参数的返回值</li><li>useCallback 缓存的是第一个参数本身</li></ul><h1 id="redux-中间件的实现原理" tabindex="-1">redux 中间件的实现原理 <a class="header-anchor" href="#redux-中间件的实现原理" aria-label="Permalink to &quot;redux 中间件的实现原理&quot;">​</a></h1>',17),l=[s];function i(c,u,h,n,d,b){return t(),a("div",null,l)}const k=e(o,[["render",i]]);export{f as __pageData,k as default};
