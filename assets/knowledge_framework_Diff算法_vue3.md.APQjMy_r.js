import{_ as e,c as o,o as l,U as a}from"./chunks/framework.RtLYYSF3.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/Diff算法/vue3.md","filePath":"knowledge/framework/Diff算法/vue3.md"}'),i={name:"knowledge/framework/Diff算法/vue3.md"},d=a('<p>在 Vue 3 中，Diff 算法结合了最长递增子序列（LIS）的优化和传统的双端比较方法来处理列表的更新</p><ol><li><p><strong>双端比较</strong>：</p><ul><li>Vue 3 首先使用双端比较策略来快速处理那些简单的、可以通过头尾比较直接确定的节点更新。</li><li>这包括检查新旧列表的开始和结束节点，对它们进行比较，以快速处理未改变的节点或显而易见的节点移动。</li></ul></li><li><p><strong>中间部分的处理</strong>：</p><ul><li>对于列表中间的部分，特别是当节点顺序发生了变化时，Vue 3 会使用最长递增子序列来优化这个过程。</li><li>这涉及到标记和保留那些不需要移动的节点，这是通过计算最长递增子序列来实现的。</li></ul></li><li><p><strong>结合两种策略</strong>：</p><ul><li>双端比较快速处理明显没有变化或位置变化很大的节点。</li><li>对于剩余的、可能顺序发生变化的节点，通过最长递增子序列来最小化DOM操作。</li></ul></li></ol><h3 id="为什么需要结合两种策略" tabindex="-1">为什么需要结合两种策略？ <a class="header-anchor" href="#为什么需要结合两种策略" aria-label="Permalink to &quot;为什么需要结合两种策略？&quot;">​</a></h3><ul><li><strong>性能优化</strong>：双端比较在处理头尾节点时非常高效，能快速定位到需要改变的节点。而LIS优化能在节点顺序变化时最小化DOM操作。</li><li><strong>最小化DOM操作</strong>：通过结合这两种策略，Vue 3 能够在更新列表时最小化DOM操作的数量，这是提高大型应用性能的关键。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>Vue 3 的 Diff 算法通过这种混合策略，实现了在处理各种复杂更新场景时的高效性能，尤其是在处理具有复杂子节点结构的大型列表时。这种方法使得 Vue 3 在性能上相比于 Vue 2 有了显著的提升。</p><p>在 Vue 3 中，当您有一个初始列表 <code>a, b, c, d, e</code>，并且它更新为 <code>d, e, f, a, b, c</code> 时，Diff 算法结合最长递增子序列（LIS）的应用过程如下：</p><h3 id="_1-初始和更新的列表" tabindex="-1">1. 初始和更新的列表 <a class="header-anchor" href="#_1-初始和更新的列表" aria-label="Permalink to &quot;1. 初始和更新的列表&quot;">​</a></h3><ul><li><strong>原始列表</strong>：<code>a, b, c, d, e</code></li><li><strong>更新后的列表</strong>：<code>d, e, f, a, b, c</code></li></ul><h3 id="_2-生成旧节点在新列表中的位置映射" tabindex="-1">2. 生成旧节点在新列表中的位置映射 <a class="header-anchor" href="#_2-生成旧节点在新列表中的位置映射" aria-label="Permalink to &quot;2. 生成旧节点在新列表中的位置映射&quot;">​</a></h3><p>首先，算法会遍历新列表，创建一个映射来标记旧列表中每个节点在新列表中的位置。如果某个旧节点不在新列表中，则标记为 -1。</p><ul><li>映射结果：<code>[3, 4, 5, 0, 1]</code><ul><li><code>a</code>（旧列表中第一个元素）现在在新列表中的位置是 3</li><li><code>b</code> 在新列表中的位置是 4</li><li><code>c</code> 在新列表中的位置是 5</li><li><code>d</code> 在新列表中的位置是 0</li><li><code>e</code> 在新列表中的位置是 1</li><li><code>f</code> 是新添加的节点，不在旧列表中</li></ul></li></ul><h3 id="_3-寻找最长递增子序列" tabindex="-1">3. 寻找最长递增子序列 <a class="header-anchor" href="#_3-寻找最长递增子序列" aria-label="Permalink to &quot;3. 寻找最长递增子序列&quot;">​</a></h3><p>接下来，Vue 会在这个映射数组中寻找最长递增子序列。在这个例子中，最长递增子序列是 <code>[3, 4, 5]</code>。</p><h3 id="_4-根据最长递增子序列更新dom" tabindex="-1">4. 根据最长递增子序列更新DOM <a class="header-anchor" href="#_4-根据最长递增子序列更新dom" aria-label="Permalink to &quot;4. 根据最长递增子序列更新DOM&quot;">​</a></h3><p>然后，Vue 使用这个信息来优化DOM操作：</p><ul><li><strong>保留</strong>：最长递增子序列 <code>[3, 4, 5]</code> 对应于原始列表中的 <code>a, b, c</code>。这意味着 <code>a, b, c</code> 可以保持不变，不需要移动。</li><li><strong>移动</strong>：<code>d, e</code> 在新列表中排在最前面，所以需要将它们移动到列表的开始位置。</li><li><strong>添加</strong>：<code>f</code> 是新列表中的新元素，需要被添加。</li><li><strong>结果</strong>：最终的DOM操作将是将 <code>d, e</code> 移动到列表的开始位置，添加 <code>f</code> 在 <code>e</code> 后面，然后是不变的 <code>a, b, c</code>。</li></ul><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>通过使用最长递增子序列，Vue 3 的 Diff 算法能够以更高效的方式处理列表中节点的重排。在这个例子中，只有 <code>d, e</code> 需要移动，<code>f</code> 被添加，而 <code>a, b, c</code> 保持不动。这种优化减少了不必要的DOM操作，特别是在处理大型列表时，可以显著提高性能。</p>',19),c=[d];function r(t,n,s,u,h,f){return l(),o("div",null,c)}const g=e(i,[["render",r]]);export{p as __pageData,g as default};
