import{_ as e,c as l,o as a,U as i}from"./chunks/framework.n5rCxQTk.js";const m=JSON.parse('{"title":"1.性能优化 （RAIL 模型）","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/performance/RAIL模型.md","filePath":"knowledge/performance/RAIL模型.md"}'),o={name:"knowledge/performance/RAIL模型.md"},r=i('<h1 id="_1-性能优化-rail-模型" tabindex="-1">1.性能优化 （RAIL 模型） <a class="header-anchor" href="#_1-性能优化-rail-模型" aria-label="Permalink to &quot;1.性能优化 （RAIL 模型）&quot;">​</a></h1><blockquote><p>参考链接： <a href="https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn" target="_blank" rel="noreferrer">https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn</a></p></blockquote><p>使用 RAIL 模型评估性能：</p><ul><li>响应(Response)：在 100 毫秒以内响应。</li><li>动画(Animation)：设置动画或滚动时，在 10 毫秒以内生成帧。</li><li>空闲(Idle)：最大程度增加空闲时间。</li><li>加载(Load)：在 1000 毫秒以内呈现内容（关键渲染路径）。</li></ul><h2 id="_1-1-响应" tabindex="-1">1.1 响应 <a class="header-anchor" href="#_1-1-响应" aria-label="Permalink to &quot;1.1 响应&quot;">​</a></h2><p>在 100ms 内响应用户操作，他们会觉得可以立即获得结果。时间再长，操作与反应之间的连接就会中断。对于需要超过 500 毫秒才能完成的操作，始终提供反馈。</p><h2 id="_1-2-动画-渲染性能" tabindex="-1">1.2 动画（渲染性能） <a class="header-anchor" href="#_1-2-动画-渲染性能" aria-label="Permalink to &quot;1.2 动画（渲染性能）&quot;">​</a></h2><p>目前大多数设备的屏幕刷新率为 60Hz，所以尽可能使动画保持 60fps。由于浏览器有整理工作要做，因此每一帧的工作需要在 10 毫秒内完成。</p><ul><li>优化 JavaScript 执行 <ul><li>对于动画效果的实现，避免使用<code>setTimeout</code>或<code>setInterval</code>，请使用<code>requestAnimationFrame</code>。</li><li>将长时间运行的 JavaScript 从主线程移到 Web Worker。</li><li>使用微任务来执行对多个帧的 DOM 更改。</li></ul></li><li>缩小样式计算的范围并降低其复杂性 <ul><li>降低选择器的复杂性，比如 BEM 命名规范。</li><li>减少在元素更改时需要计算的工作量。</li></ul></li><li>避免大型、复杂的布局和布局抖动 <ul><li>布局的作用范围一般为整个文档。</li><li>DOM 元素的数量将影响性能；应尽可能避免触发布局。</li><li>避免强制同步布局和布局抖动；先读取样式值，然后进行样式更改。</li></ul></li><li>简化绘制的复杂度、减小绘制区域 <ul><li>除<code>transform</code>或<code>opacity</code>属性之外，更改任何属性始终都会触发绘制。</li><li>通过层的提升和动画的编排来减少绘制区域。</li></ul></li><li>坚持更改可以由合成线程单独处理的属性、控制层数 <ul><li>坚持使用<code>transform</code>和<code>opacity</code>属性更改来实现动画。</li><li>使用<code>will-change</code>或<code>translateZ</code>提升移动的元素(推荐使用<code>will-change: transform;</code>) 。</li><li>避免过度使用提升规则；各层都需要内存和管理开销。</li></ul></li><li>使输入处理程序去抖 <ul><li>避免长时间运行输入处理程序；它们可能阻止滚动。</li><li>不要在输入处理程序中进行样式更改（将触发强制同步布局）。</li><li>使滚动处理程序去除抖动。</li></ul></li></ul><h2 id="_1-3-空闲" tabindex="-1">1.3 空闲 <a class="header-anchor" href="#_1-3-空闲" aria-label="Permalink to &quot;1.3 空闲&quot;">​</a></h2><p>用户没有与页面交互，但主线程应足够用于处理下一个用户输入。如果用户开始交互，优先级最高的事项是响应用户。例如，往页面里插入 10,000 个 dom，如果直接插入，势必造成主线程阻塞、页面假死，要实现小于 100 毫秒的响应，应用必须在每 50 毫秒内将控制返回给主线程，可以每隔 50ms 插入 100 个 dom，既可以完成任务，又能确保即时的响应。</p><h2 id="_1-4-加载-关键渲染路径" tabindex="-1">1.4 加载（关键渲染路径） <a class="header-anchor" href="#_1-4-加载-关键渲染路径" aria-label="Permalink to &quot;1.4 加载（关键渲染路径）&quot;">​</a></h2><p>为了尽快完成关键渲染路径，应当最大限度减小三种可变元素：关键资源的数量、大小，关键路径长度。具体如下：</p><ul><li>减少关键资源的数量：删除它们、延迟它们的下载（懒加载），将它们标记为异步等。</li><li>减小传送大小：压缩代码，利用缓存等。</li><li>优化关键资源的加载顺序：尽可能提早下载（预加载），以缩短关键路径长度。</li></ul>',14),t=[r];function c(n,d,s,h,_,u){return a(),l("div",null,t)}const f=e(o,[["render",c]]);export{m as __pageData,f as default};
