import{_ as e,c as a,o as t,U as l}from"./chunks/framework.n5rCxQTk.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/performance/白屏优化.md","filePath":"knowledge/performance/白屏优化.md"}'),o={name:"knowledge/performance/白屏优化.md"},r=l('<h2 id="白屏问题-优化关键渲染路径" tabindex="-1">白屏问题（优化关键渲染路径） <a class="header-anchor" href="#白屏问题-优化关键渲染路径" aria-label="Permalink to &quot;白屏问题（优化关键渲染路径）&quot;">​</a></h2><blockquote><p>参考：<a href="https://juejin.im/post/5d00820b5188255ee806a1c7" target="_blank" rel="noreferrer">https://juejin.im/post/5d00820b5188255ee806a1c7</a></p></blockquote><h3 id="分析-白屏时间内发生了什么" tabindex="-1">分析：白屏时间内发生了什么？ <a class="header-anchor" href="#分析-白屏时间内发生了什么" aria-label="Permalink to &quot;分析：白屏时间内发生了什么？&quot;">​</a></h3><ul><li>用户按下回车，浏览器解析网址，DNS 查询，通过 IP 发生 HTTP 请求。</li><li>服务端返回 HTML，浏览器解析 HTML，并在此过程中加载 css 和 js。</li><li>执行 js，创建各种 DOM 并渲染到根节点，直到第一个可视元素出现。</li></ul><h3 id="从以下维度去优化" tabindex="-1">从以下维度去优化 <a class="header-anchor" href="#从以下维度去优化" aria-label="Permalink to &quot;从以下维度去优化&quot;">​</a></h3><ul><li>过大的文件会拖慢加载速度。对应的解决方案就是压缩、拆包、treeshaking、差异化加载（es6+和 es5 双份资源，动态 polyfill）、缓存等。</li><li>Chrome 的并发限制数量为 6，所以关键资源的数量过多也会加剧白屏时间。对应的解决方案就是删除、延迟、标记为异步、使用用 http2、http3 等。</li><li>页面直出。大部分 web 应用的可视元素都是由 js 执行创建插入的，这个过程很明显是可以提前的。手段有服务端渲染、预渲染等。也可以给应用添加骨架屏、Loading 指示等，也算是预渲染。</li><li>当然还有路由跳转之间的优化，可以开启 preload、dnsprefetch、keep-alive 等。</li></ul>',6),i=[r];function n(s,c,_,d,h,p){return t(),a("div",null,i)}const m=e(o,[["render",n]]);export{f as __pageData,m as default};
