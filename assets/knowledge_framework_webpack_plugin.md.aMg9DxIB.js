import{_ as a,c as e,o,U as i}from"./chunks/framework.RtLYYSF3.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/webpack/plugin.md","filePath":"knowledge/framework/webpack/plugin.md"}'),l={name:"knowledge/framework/webpack/plugin.md"},t=i('<h2 id="plugin" tabindex="-1">Plugin <a class="header-anchor" href="#plugin" aria-label="Permalink to &quot;Plugin&quot;">​</a></h2><h3 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h3><p>如果说 Loader 负责文件转换，那么 Plugin 便是负责功能扩展。</p><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><p>基于发布订阅模式，自己实现的一套 Tapable 事件流方案，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现自己想要的功能。compiler 暴露了和 webpack 整个生命周期相关的钩子（Compiler Hooks），而 compilation 则暴露了与模块和依赖有关的粒度更小的事件钩子（Compilation Hooks）。</p><h3 id="开发原则" tabindex="-1">开发原则 <a class="header-anchor" href="#开发原则" aria-label="Permalink to &quot;开发原则&quot;">​</a></h3><ul><li>插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例</li><li>传给每个插件的 compiler 和 compilation 对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</li><li>异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住</li></ul>',7),r=[t];function n(c,p,s,d,_,h){return o(),e("div",null,r)}const k=a(l,[["render",n]]);export{m as __pageData,k as default};
