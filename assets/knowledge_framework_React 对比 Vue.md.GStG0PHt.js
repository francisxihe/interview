import{_ as e,c as a,o,U as t}from"./chunks/framework.RtLYYSF3.js";const k=JSON.parse('{"title":"React VS Vue","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/React 对比 Vue.md","filePath":"knowledge/framework/React 对比 Vue.md"}'),i={name:"knowledge/framework/React 对比 Vue.md"},l=t('<h1 id="react-vs-vue" tabindex="-1">React VS Vue <a class="header-anchor" href="#react-vs-vue" aria-label="Permalink to &quot;React VS Vue&quot;">​</a></h1><blockquote><p><a href="https://www.zhihu.com/question/301860721/answer/724759264" target="_blank" rel="noreferrer">https://www.zhihu.com/question/301860721/answer/724759264</a> &gt; <a href="https://zhuanlan.zhihu.com/p/133819602?utm_source=cn.ticktick.task&amp;utm_medium=social&amp;utm_oi=33033587523584" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/133819602?utm_source=cn.ticktick.task&amp;utm_medium=social&amp;utm_oi=33033587523584</a></p></blockquote><h2 id="开发体验-直观感受" tabindex="-1">开发体验/直观感受 <a class="header-anchor" href="#开发体验-直观感受" aria-label="Permalink to &quot;开发体验/直观感受&quot;">​</a></h2><ul><li>React 追求简单灵活</li><li>Vue 追求易用，上手难度低，心智负担相对较少，语法糖较多</li></ul><h2 id="api-设计风格" tabindex="-1">API 设计风格 <a class="header-anchor" href="#api-设计风格" aria-label="Permalink to &quot;API 设计风格&quot;">​</a></h2><ul><li>Vue 进行数据拦截/代理，它对侦测数据的变化更敏感、更精确，也间接对一些后续实现（比如 hooks，function based API）提供了很大的便利。</li><li>React 推崇函数式，它直接进行局部重新刷新（或者重新渲染），这样更粗暴，但是更简单，让我们的开发回到了上古时代，就是刷新呗，前端开发非常简单。但是 React 并不知道什么时候“应该去刷新”，触发局部重新变化是由开发者手动调用 setState 完成。</li></ul><h2 id="哲学理念-以事件系统为例" tabindex="-1">哲学理念(以事件系统为例) <a class="header-anchor" href="#哲学理念-以事件系统为例" aria-label="Permalink to &quot;哲学理念(以事件系统为例)&quot;">​</a></h2><ul><li>React 设计是改变开发者，提供强大而复杂的机制，开发者按照我的来；</li><li>Vue 是适应开发者，让开发者怎么爽怎么来。</li></ul><h2 id="性能上" tabindex="-1">性能上 <a class="header-anchor" href="#性能上" aria-label="Permalink to &quot;性能上&quot;">​</a></h2><ul><li>React 选择快速响应用户，让用户觉得够快，不能阻塞用户的交互。(Fiber 时间切片)</li><li>Vue 选择优化每个任务，让它有多快就多快，挤压 CPU 运算量。(预编译优化)</li></ul><h2 id="说到抄袭" tabindex="-1">说到抄袭 <a class="header-anchor" href="#说到抄袭" aria-label="Permalink to &quot;说到抄袭&quot;">​</a></h2><p>一种新的模式的出现的值得框架之间相互借鉴和学习的，毕竟框架归根结底的目的不是为了「标榜自己的特立独行」，而是「方便广大开发者」。这是值得思考的一点，很多人似乎觉得一个框架用了某种模式，另一个框架就不能用，其实这对于框架之间的进步和发展并没有什么好处。更何况 React 社区也一样有对 Vue 的借鉴，比如你看 react-router@6 的 api，你会发现很多地方和 vue-router 非常相似了。比如 useRoutes 的「配置式路由」，以及在组件中使子路由的代码结构等等。</p><h1 id="逻辑复用" tabindex="-1">逻辑复用 <a class="header-anchor" href="#逻辑复用" aria-label="Permalink to &quot;逻辑复用&quot;">​</a></h1><blockquote><p>参考链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/68477600</a></li><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noreferrer">https://zh-hans.reactjs.org/docs/hooks-intro.html</a></li><li><a href="https://mp.weixin.qq.com/s/P_6ADwhnMpo3gdWBKh2gZQ" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/P_6ADwhnMpo3gdWBKh2gZQ</a></li></ul></blockquote><p>Dan 在他的博客上提到：</p><blockquote><p>我们知道组件和自上而下的数据流可以帮助我们将大型 UI 组织成小型，独立，可重用的部分。 但是，我们经常无法进一步破坏复杂组件，因为逻辑是有状态的，无法提取到函数或其他组件中。而 hook 让我们可以将组件内部的逻辑组织成可重用的隔离单元。</p></blockquote><p>所以，一句话总结 hook 带来的变革就是：<strong>将可复用的最小单元从组件层面进一步细化到逻辑层面</strong>。</p><p>基于这一点优势，在后面我们看可以看到，基于 hook 开发的应用里的所有组件都不会随业务增长而变得臃肿，因为在 hook 的世界里，状态逻辑和 UI 是解耦的。UI 只需要消费最终计算出来的状态数据，hook 只关注状态的计算和改变。</p><h2 id="hoc-render-prop-vue-scoped-slots-mixins-缺点" tabindex="-1">HOC / render prop（Vue scoped slots）/ Mixins 缺点： <a class="header-anchor" href="#hoc-render-prop-vue-scoped-slots-mixins-缺点" aria-label="Permalink to &quot;HOC / render prop（Vue scoped slots）/ Mixins 缺点：&quot;">​</a></h2><ul><li>参数来源不清晰，不利于追踪。</li><li>命名空间冲突。</li><li>需要重新组织你的组件结构，容易导致嵌套地狱。</li><li>HOC 需要创建额外的实例来包裹，导致无畏的性能开销。</li></ul><h2 id="hook-优点-解决的问题" tabindex="-1">Hook 优点（解决的问题）: <a class="header-anchor" href="#hook-优点-解决的问题" aria-label="Permalink to &quot;Hook 优点（解决的问题）:&quot;">​</a></h2><ul><li>参数来源清晰，从函数返回；</li><li>返回值可以被任意重命名，所以不存在命名空间冲突；</li><li>没有创建额外的组件实例所带来的性能损耗；</li><li>无需修改组件结构的情况下复用状态逻辑，分享或复用变得更便捷（在组件间复用状态逻辑难）</li><li>Hook 使你在非 class 的情况下可以使用更多的 React 特性（难以理解的 class：this 机制，不利于代码压缩、热更新)</li><li>组件中相互关联的部分拆分成更小的函数（复杂组件变得难以理解：充斥着状态逻辑和副作用）</li></ul><h2 id="hook-缺点" tabindex="-1">Hook 缺点 <a class="header-anchor" href="#hook-缺点" aria-label="Permalink to &quot;Hook 缺点&quot;">​</a></h2><ul><li>ref 的心智负担。（旧引用问题）</li><li>useEffect 依赖数组的心智负担。一不留神就被意外调用了。不得不借助 eslint 来提醒</li></ul><h2 id="对比-vue-composition-api" tabindex="-1">对比 Vue Composition Api <a class="header-anchor" href="#对比-vue-composition-api" aria-label="Permalink to &quot;对比 Vue Composition Api&quot;">​</a></h2><ul><li>vue setup 只执行一遍，不存在旧引用问题。</li><li>vue watchEffect 自动收集依赖，自动触发，所以也没有依赖的心智负担。</li><li>vue ref 需要在 ref 和 ref.value 之间频繁切换。在没有 Typescript 的项目中体验太糟糕了。不过有新的提案正在解决这个事。</li><li>vue 自带的 API，比如 reactive，类型定义太复杂了，在 typescript 中出现意想不到的、不符合直觉的类型错误。</li></ul>',26),r=[l];function h(s,u,n,c,p,d){return o(),a("div",null,r)}const _=e(i,[["render",h]]);export{k as __pageData,_ as default};
