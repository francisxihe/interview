import{_ as s,c as i,m as o,a,t,U as l,o as n}from"./chunks/framework.n5rCxQTk.js";const m=JSON.parse('{"title":"web","description":"","frontmatter":{"title":"web"},"headers":[],"relativePath":"knowledge/web/index.md","filePath":"knowledge/web/index.md"}'),r={name:"knowledge/web/index.md"},d={id:"frontmatter-title",tabindex:"-1"},c=o("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),h=l('<h3 id="session-和-cookie-的区别" tabindex="-1">session 和 cookie 的区别 <a class="header-anchor" href="#session-和-cookie-的区别" aria-label="Permalink to &quot;session 和 cookie 的区别&quot;">​</a></h3><p><span class="tag red">淘天</span></p><details class="details custom-block"><summary>题解</summary><h4 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h4><p>Cookie 是由 Web 服务器发送到用户浏览器的小片段的数据，浏览器会存储这些数据并在之后的请求中将其发送回服务器，主要用于存储协同客户端和服务器两端的数据。</p><h4 id="session" tabindex="-1">Session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;Session&quot;">​</a></h4><p>Session 是服务器端用来维护用户状态信息的一种机制。</p><h4 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h4><ul><li><p><strong>存储位置</strong>：Cookie 客户端（用户的浏览器）和服务器都存，Session 存储在服务器端。</p></li><li><p><strong>安全性</strong>：Cookie 在客户端存储，所以相对较不安全。容易受到跨站脚本攻击（XSS）和其他形式的攻击。Session 通常比 Cookie 更安全，因为它不容易受到客户端的干扰和攻击。</p></li><li><p><strong>生命周期</strong>：Cookie 的生命周期可以由开发者控制，而 Session 的生命周期通常由服务器设置。</p></li><li><p><strong>性能考虑</strong>：Session 可能对服务器的性能有较大影响，特别是在处理大量用户时。</p></li><li><p><strong>数据容量</strong>：Cookie 有大小限制，通常被限制在 4KB 左右，而 Session 可以存储更多的数据。</p></li><li><p><strong>用途和适用场景</strong>：Cookie 适合存储持久化的用户偏好设置和跟踪用户会话；Session 更适合存储临时的敏感数据。</p></li></ul><p>在实际应用中，开发者经常将二者结合使用，比如使用 Cookie 来存储一个唯一的 Session 标识符，而将具体的用户数据存储在 Session 中，从而结合二者的优点。</p></details><h3 id="如果部署了两台云服务器-登录功能需要服务端保存-session-不同的服务器如何共享-session" tabindex="-1">如果部署了两台云服务器，登录功能需要服务端保存 session，不同的服务器如何共享 session？ <a class="header-anchor" href="#如果部署了两台云服务器-登录功能需要服务端保存-session-不同的服务器如何共享-session" aria-label="Permalink to &quot;如果部署了两台云服务器，登录功能需要服务端保存 session，不同的服务器如何共享 session？&quot;">​</a></h3><p><span class="tag red">淘天</span></p><details class="details custom-block"><summary>题解</summary><h4 id="_1-使用粘性会话-session-stickiness" tabindex="-1">1. 使用粘性会话（Session Stickiness） <a class="header-anchor" href="#_1-使用粘性会话-session-stickiness" aria-label="Permalink to &quot;1. 使用粘性会话（Session Stickiness）&quot;">​</a></h4><p>粘性会话是一种确保用户的所有请求都被路由到同一台服务器的方法。这是通过负载均衡器实现的，它根据特定的标识（如 Cookie）来确定将请求路由到哪台服务器。</p><ul><li><strong>优点</strong>：实施简单，不需要更改应用程序。</li><li><strong>缺点</strong>：如果一台服务器宕机，那么存储在该服务器上的会话信息将丢失。这也影响了系统的可扩展性和容错能力。</li></ul><h4 id="_2-使用集中式-session-管理" tabindex="-1">2. 使用集中式 Session 管理 <a class="header-anchor" href="#_2-使用集中式-session-管理" aria-label="Permalink to &quot;2. 使用集中式 Session 管理&quot;">​</a></h4><p>在这种方法中，会话信息存储在所有服务器都可以访问的中央位置，如数据库或专门的缓存服务器（如 Redis、Memcached）。</p><ul><li><strong>优点</strong>：提高了应用的可用性和伸缩性。即使一台服务器宕机，会话信息仍然保持可用。</li><li><strong>缺点</strong>：可能会增加响应时间（由于网络延迟和额外的数据存储操作），并可能需要额外的基础设施支持。</li></ul><h4 id="_3-使用分布式缓存" tabindex="-1">3. 使用分布式缓存 <a class="header-anchor" href="#_3-使用分布式缓存" aria-label="Permalink to &quot;3. 使用分布式缓存&quot;">​</a></h4><p>分布式缓存（如 Redis Cluster）可以用来在多个服务器之间共享 Session。与集中式 Session 管理相似，但是它是分布式的，提供了更好的性能和可扩展性。</p><ul><li><strong>优点</strong>：高性能，可伸缩性好。</li><li><strong>缺点</strong>：相比于集中式 Session 管理，实现更复杂，需要额外的基础设施和配置。</li></ul><h4 id="_4-使用-jwt-json-web-tokens" tabindex="-1">4. 使用 JWT（JSON Web Tokens） <a class="header-anchor" href="#_4-使用-jwt-json-web-tokens" aria-label="Permalink to &quot;4. 使用 JWT（JSON Web Tokens）&quot;">​</a></h4><p>JSON Web Token（JWT）是一种开放标准（RFC 7519），用于在各方之间安全地传输信息作为 JSON 对象。由于其小巧和自包含的特性，JWT 特别适用于分布式站点的单点登录（SSO）场景。</p><p>每次用户认证后，服务器生成一个 JWT 并发送给客户端，客户端随后的每个请求都携带这个 JWT。</p><h5 id="jwt-的结构" tabindex="-1">JWT 的结构 <a class="header-anchor" href="#jwt-的结构" aria-label="Permalink to &quot;JWT 的结构&quot;">​</a></h5><p>JWT 通常包含三个部分，用点（<code>.</code>）分隔：</p><ol><li><strong>头部（Header）</strong>：</li></ol><p>描述 JWT 的元数据，比如<code>{&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;}</code>包含令牌的类型（<code>typ</code>，通常是 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</p><ol start="2"><li><p><strong>有效载荷（Payload）</strong>：</p><ul><li>包含所要传输的数据。这些数据被称为“声明”（Claims），分为三种类型：注册声明（如 iss、exp、sub）、公共声明、私有声明。</li><li>注册声明是预定义的，不是强制的，但推荐使用。例如，<code>iss</code>（发行者）、<code>exp</code>（过期时间）、<code>sub</code>（主题）等。</li><li>公共声明是自定义的声明，用于共享信息。</li><li>私有声明是创建者和消费者共同定义的声明。</li></ul></li><li><p><strong>签名（Signature）</strong>：</p><ul><li>为了防止数据篡改，对头部和有效载荷进行签名。</li><li>签名是使用头部中指定的算法和密钥进行的。</li><li>在验证 JWT 时，接收方会对签名进行验证以确保数据的完整性。</li></ul></li></ol><h5 id="jwt-的使用流程" tabindex="-1">JWT 的使用流程 <a class="header-anchor" href="#jwt-的使用流程" aria-label="Permalink to &quot;JWT 的使用流程&quot;">​</a></h5><ol><li><strong>用户认证</strong>：用户通过用户名和密码登录。</li><li><strong>生成 JWT</strong>：认证成功后，服务器生成一个 JWT，并将其发送回用户。</li><li><strong>客户端存储 JWT</strong>：客户端将 JWT 存储在本地（例如在浏览器的 localStorage 中）。</li><li><strong>发送 JWT</strong>：之后客户端每次向服务器发送请求时，都会包含这个 JWT（通常在 HTTP 请求的 Authorization 头中使用 Bearer 模式）。</li><li><strong>服务器验证 JWT</strong>：服务器验证 JWT 的签名，检查其有效性（如是否过期），并从中提取用户信息以完成认证和授权。</li></ol><h5 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h5><ul><li><strong>无状态和可伸缩性</strong>：由于不需要在服务器上存储会话信息，JWT 是无状态的，这使得应用易于扩展。</li><li><strong>自包含</strong>：JWT 包含所有必要的信息，减少了多次数据库查询。</li><li><strong>支持跨域认证</strong>：非常适合单页应用（SPA）和分布式微服务架构。</li></ul><h5 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h5><ul><li><strong>安全性问题</strong>：JWT 一旦被截获，就有被滥用的风险，因此需要通过 HTTPS 等方式确保安全传输。</li><li><strong>无法废止</strong>：由于 JWT 是自包含的，一旦发出，无法从服务器端撤销，直到它过期。这对于处理长期有效的令牌可能是个问题。</li><li><strong>存储大小限制</strong>：JWT 由于需要在每个请求中发送，因此不适合存储大量的用户信息。</li></ul></details>',6);function u(e,g,p,k,b,T){return n(),i("div",null,[o("h1",d,[a(t(e.$frontmatter.title)+" ",1),c]),h])}const _=s(r,[["render",u]]);export{m as __pageData,_ as default};
